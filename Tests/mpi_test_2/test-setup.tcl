
# generated by stc
# date: 2012/11/19 11:54:58

package require turbine 0.0.6
namespace import turbine::*


proc swift:constants {  } {
    turbine::c::log "function:swift:constants"
    global c:b_true
    turbine::allocate c:b_true integer
    turbine::store_integer ${c:b_true} 1
    global c:f_0.0
    turbine::allocate c:f_0.0 float
    turbine::store_float ${c:f_0.0} 0.0
    global c:i_0
    turbine::allocate c:i_0 integer
    turbine::store_integer ${c:i_0} 0
    global c:i_1
    turbine::allocate c:i_1 integer
    turbine::store_integer ${c:i_1} 1
}

package require setup 0.0.1


proc swift:main {  } {
    turbine::c::log "enter function: main"
    set stack 0
    turbine::allocate u:x float
    turbine::allocate_container u:A integer
    turbine::allocate_container t:2 integer
    turbine::allocate u:w float
    global c:i_1
    global c:f_0.0
    global c:i_0
    global c:b_true
    # Swift l.7: assigning expression to x
    setup::c_setup ${stack} [ list ${u:x} ] [ list ${c:f_0.0} ]
    turbine::rangestep ${stack} [ list ${t:2} ] [ list ${c:i_0} ${c:i_1} ${c:i_1} ]
    turbine::c::rule main-explicitwait0 [ list ${u:x} ] ${turbine::LOCAL} [ list main-explicitwait0 ${stack} ]
    adlb::slot_create ${u:A}
    turbine::c::rule main-foreach_arr_wait0 [ list ${t:2} ] ${turbine::LOCAL} [ list main-foreach_arr_wait0 ${stack} ${u:A} ${t:2} ${c:f_0.0} ]
    turbine::c::rule main-forloop-0 [ list ${c:b_true} ] ${turbine::CONTROL} [ list main-forloop-0 ${stack} ${c:b_true} ${c:i_0} ${u:w} ${u:A} ]
    turbine::c::rule main-explicitwait3 [ list ${u:w} ] ${turbine::LOCAL} [ list main-explicitwait3 ${stack} ${c:f_0.0} ]
    adlb::slot_drop ${u:A}
}


proc main-explicitwait0 { stack } {
    # Swift l.9 evaluating  expression and throwing away 0 results
    turbine::printf_local "Setup called finished.\n"
}


proc main-foreach_arr_wait0 { stack u:A t:2 c:f_0.0 } {
    set tcltmp:contents [ adlb::enumerate ${t:2} members all 0 ]
    foreach u:i ${tcltmp:contents} {
        turbine::allocate t:6 float
        # Swift l.15: assigning expression to A[_]
        setup::c_run ${stack} [ list ${t:6} ] [ list ${c:f_0.0} ]
        turbine::container_f_insert no_stack [ list ] [ list ${u:A} ${u:i} ${t:6} ]
        turbine::c::rule main-explicitwait1 [ list ${t:6} ] ${turbine::LOCAL} [ list main-explicitwait1 ${stack} ]
    }
    adlb::slot_drop ${u:A}
}


proc main-explicitwait1 { stack } {
    # Swift l.17 evaluating  expression and throwing away 0 results
    turbine::printf_local "a single run finished"
}


proc main-forloop-0 { stack u:__xcond0 u:j u:w u:A } {
    # Value __v___xcond0 with type $boolean was defined
    set v:__xcond0 [ turbine::retrieve_integer ${u:__xcond0} ]
    if { ${v:__xcond0} } {
        turbine::allocate t:14 float
        turbine::allocate t:15 integer
        turbine::allocate t:18 integer
        turbine::allocate t:20 integer
        turbine::f_reference no_stack [ list ] [ list ${u:A} ${u:j} ${t:15} integer ]
        turbine::f_dereference_float no_stack ${t:14} ${t:15}
        turbine::c::rule main-forloop-0 [ list ${t:20} ] ${turbine::CONTROL} [ list main-forloop-0 ${stack} ${t:20} ${t:18} ${u:w} ${u:A} ]
        turbine::c::rule main-explicitwait2 [ list ${t:14} ] ${turbine::LOCAL} [ list main-explicitwait2 ${stack} ${u:w} ${u:j} ]
        turbine::c::rule main-optinserted [ list ${u:j} ] ${turbine::LOCAL} [ list main-optinserted ${stack} ${u:j} ${t:18} ${t:20} ]
    } else {
    }
}


proc main-explicitwait2 { stack u:w u:j } {
    # Value __ov_j-0 with type $int was defined
    # Value __ov___t16-1 with type $boolean was defined
    set optv:j-0 [ turbine::retrieve_integer ${u:j} ]
    set optv:__t16-1 [ expr ${optv:j-0} == 1 ]
    if { ${optv:__t16-1} } {
        # Swift l.24: assigning expression to w
        turbine::store_float ${u:w} 0.0
    }
}


proc main-optinserted { stack u:j t:18 t:20 } {
    # Value __ov_j-2 with type $int was defined
    # Value __ov___t18-4 with type $int was defined
    # Value __ov___t20-7 with type $boolean was defined
    set optv:j-2 [ turbine::retrieve_integer ${u:j} ]
    set optv:__t18-4 [ expr ${optv:j-2} + 1 ]
    turbine::store_integer ${t:18} ${optv:__t18-4}
    set optv:__t20-7 [ expr ${optv:__t18-4} < 2 ]
    turbine::store_integer ${t:20} ${optv:__t20-7}
}


proc main-explicitwait3 { stack c:f_0.0 } {
    turbine::allocate u:z float
    # Swift l.29: assigning expression to z
    setup::c_cleanup ${stack} [ list ${u:z} ] [ list ${c:f_0.0} ]
    turbine::c::rule main-explicitwait4 [ list ${u:z} ] ${turbine::LOCAL} [ list main-explicitwait4 ${stack} ]
}


proc main-explicitwait4 { stack } {
    # Swift l.31 evaluating  expression and throwing away 0 results
    turbine::printf_local "Cleanup finished.\n"
}

turbine::defaults
turbine::init $engines $servers
turbine::start swift:main swift:constants
turbine::finalize

